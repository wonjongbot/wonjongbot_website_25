<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>wonjongbot/projects/kernel/</title>
<meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="all,follow"><meta name=googlebot content="index,follow,snippet,archive"><link rel=stylesheet href=https://wonjongbot.com/hugo-theme-console/css/terminal-0.7.4.min.css><link rel=stylesheet href=https://wonjongbot.com/hugo-theme-console/css/animate-4.1.1.min.css><link rel=stylesheet href=https://wonjongbot.com/hugo-theme-console/css/console.css><!--[if lt IE 9]><script src=https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js></script><script src=https://oss.maxcdn.com/respond/1.4.2/respond.min.js></script><![endif]--><meta property="og:title" content="Unix like kernel"><meta property="og:description" content><meta property="og:type" content="article"><meta property="og:url" content="https://wonjongbot.com/projects/kernel/"><meta property="og:image" content="https://wonjongbot.com/projects/kernel/os_small_hu_19b13190d59b4255.gif"><meta property="article:published_time" content="2023-04-15T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://wonjongbot.com/projects/kernel/os_small_hu_19b13190d59b4255.gif"><meta name=twitter:title content="Unix like kernel"><meta name=twitter:description content="ECE 391 final MP. Unix like kernel w/ vmem, syscall, multithreading and more."><script type=importmap>
      {
        "imports": {
          "three": "https://unpkg.com/three@0.152.2/build/three.module.js",
          "three/examples/jsm/geometries/TeapotGeometry.js": "https://unpkg.com/three@0.152.2/examples/jsm/geometries/TeapotGeometry.js",
          "teapot": "/threedee/teapot.js"
        }
      }
    </script></head><body class=terminal><div class=container><div class=terminal-nav><header class=terminal-logo><div class="logo terminal-prompt" style=display:flex;align-items:center><a href=https://wonjongbot.com/ style=margin-right:4px><div id=teapot-container></div></a><a href=https://wonjongbot.com/ class="no-style site-name">wonjongbot</a>:~#
<a href=https://wonjongbot.com/projects>projects</a>/<a href=https://wonjongbot.com/projects/kernel>kernel</a>/</div></header><nav class=terminal-menu><ul vocab="https://schema.org/" typeof="BreadcrumbList"><li><a href=https://wonjongbot.com/ typeof="ListItem">home/</a></li><li><a href=https://wonjongbot.com/posts/ typeof="ListItem">posts/</a></li><li><a href=https://wonjongbot.com/projects/ typeof="ListItem">projects/</a></li><li><a href=https://wonjongbot.com/cv/ typeof="ListItem">cv/</a></li></ul></nav></div></div><div class="container animated zoomIn fast"><h1>Unix like kernel</h1><div class=content_body><p>ECE 391 final MP. Unix like kernel w/ vmem, syscall, multithreading and more.</p><hr><style>@font-face{font-family:"web ibm vga 8x16";src:url(/kernel_demo/Web437_IBM_VGA_8x16.woff)format("woff")}#screen_container{border:2px dotted #aaa;padding-top:20px;margin:0;width:100%;text-align:center}#emu_text{white-space:pre;font-family:"web ibm vga 8x16";font-style:normal;font-size:var(--qemu-font-size);line-height:1em;margin:auto}#emu_screen{display:none}#hint_text{text-align:center;line-height:20px}#popup_text{text-align:center;line-height:20px;font-size:120%}#known_issue{color:red}body{min-width:100%}</style><script src=/kernel_demo/libv86.js></script><script>"use strict";window.onload=function(){var e=window.emulator=new V86({wasm_path:"/kernel_demo/v86.wasm",memory_size:32*1024*1024,vga_memory_size:4*1024,screen_container:document.getElementById("screen_container"),bios:{url:"/kernel_demo/seabios.bin"},vga_bios:{url:"/kernel_demo/vgabios.bin"},hda:{url:"/kernel_demo/mp3.img"},autostart:!0,disable_audio:!0})}</script><title>391OS-36 Online Demo</title><h2>Online Demo</h2><div id=screen_container><div id=emu_text></div><canvas id=emu_screen></canvas><p id=hint_text><b>Press Alt+F1/F2/F3 to switch terminal.<br>For more combinational keys and technical info, please refer to the <a href=./#technical-overview target=_blank>Technical Overview</a> page.<br>This page is best viewed on a computer. Refresh the page to reset the emulator.<br></p><p style=text-align:center><em>Online Demo Code thanks to <b>@Paizhang</b> (<a href=https://github.com/paizhangliu/391os36_web/tree/main>391os36_web</a>)</em><br><em>Font by VileR (<a href=https://int10h.org/oldschool-pc-fonts/readme/#legal_stuff>The Oldschool PC Font Resource</a>)</em><br><br>This demo works best on non-mobile devices</p></div><hr><h2 id=technical-overview>Technical Overview</h2><p>Contents</p><ul><li><a href=#technical-overview>Technical Overview</a><ul><li><a href=#shell-commands>Shell Commands</a></li><li><a href=#shell-shortcut-keys>Shell Shortcut Keys</a></li><li><a href=#file-system>File System</a></li><li><a href=#exception-and-exception-handlers>Exception and Exception Handlers</a></li><li><a href=#interrupt-and-interrupt-handlers>Interrupt and Interrupt Handlers</a></li><li><a href=#supported-devices-and-drivers>Supported Devices and Drivers</a></li><li><a href=#memory-addressing>Memory Addressing</a></li><li><a href=#physical-memory-layout>Physical Memory Layout</a></li><li><a href=#virtual-memory-layout>Virtual Memory Layout</a></li><li><a href=#system-calls>System Calls</a></li><li><a href=#process-controlexecutehalt>Process Control/Execute/Halt</a><ul><li><a href=#process-creation-execute-system-call>Process Creation: Execute System Call</a></li><li><a href=#process-termination-halt-system-call>Process Termination: Halt System Call</a></li></ul></li><li><a href=#process-switchingscheduler>Process Switching/Scheduler</a><ul><li><a href=#process-switching-mechanism>Process Switching Mechanism</a></li></ul></li><li><a href=#background-switching-and-multiterminals>Background Switching and Multiterminals</a><ul><li><a href=#handling-background-process-switching>Handling Background Process Switching</a></li><li><a href=#handling-active-process-switching>Handling Active Process Switching</a></li></ul></li></ul></li></ul><h3 id=shell-commands>Shell Commands</h3><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td>exit</td><td>Terminates the current shell instance. If the exited process is the root shell, a new instance is spawned.</td></tr><tr><td>[Executable] [Arg]</td><td>Searches for and executes the specified program in the current terminal. Some programs may require additional arguments (see <a href=#file-system-directory>File System Directory</a>).</td></tr></tbody></table><h3 id=shell-shortcut-keys>Shell Shortcut Keys</h3><table><thead><tr><th>Combination</th><th>Action</th><th>Description</th></tr></thead><tbody><tr><td>Alt+F1</td><td>Switch to Terminal 1</td><td>(See <a href=#background-switching-and-multiterminals>Background Switching and Multiterminals</a>)</td></tr><tr><td>Alt+F2</td><td>Switch to Terminal 2</td><td>(See <a href=#background-switching-and-multiterminals>Background Switching and Multiterminals</a>)</td></tr><tr><td>Alt+F3</td><td>Switch to Terminal 3</td><td>(See <a href=#background-switching-and-multiterminals>Background Switching and Multiterminals</a>)</td></tr><tr><td>Ctrl+L</td><td>Clear Screen</td><td>Clears the video memory and resets the cursor position.</td></tr></tbody></table><h3 id=file-system>File System</h3><p>The file system is <strong>read-only</strong> and has a total size of <strong>8MB</strong>, organized into <strong>4KB blocks</strong> consisting of a <strong>boot block, inodes, and data blocks</strong>.</p><ul><li>The <strong>boot block</strong> can track up to <strong>62 inodes</strong> and contains the <strong>root directory</strong>.</li><li>Each <strong>inode</strong> can reference up to <strong>1023 data blocks</strong>.</li><li>Thus the file system supports a <strong>maximum of 62 files</strong>, each with a maximum <strong>size of 4092KB</strong> and a <strong>filename limit of 32 characters</strong>.</li><li>The file system is <strong>flat</strong> (non-hierarchical) and <strong>does not support writing or modifications</strong>.</li></ul><h3 id=exception-and-exception-handlers>Exception and Exception Handlers</h3><p>An exception occurs when a user program (or worse, the kernel) attempts an illegal or undefined operation (e.g., division by zero, accessing invalid memory). However, an exception is not necessarily &ldquo;unexpected&rdquo;; it simply means execution has deviated from the normal control flow.</p><p>Exceptions are <strong>synchronous</strong> events, meaning they occur as a direct result of instruction execution. When an exception is triggered, the processor jumps to a predefined assembly linkage (see <a href=#context-switching-and-assembly-linkages>Context Switching and Assembly Linkages</a>), which then invokes the unified exception handler.</p><p>The exception handler typically logs an error message and debugging information. <em>(In modern kernels, if the exception is recoverable, the process receives a signal, allowing it to handle the error. However, our OS does not support signals.)</em> If no handler is installed, the default behavior is to terminate the offending process.</p><p>If an exception occurs in <strong>kernel mode</strong>, it is considered fatal and non-recoverable. In this case, the kernel halts execution, requiring a system reboot.</p><h3 id=interrupt-and-interrupt-handlers>Interrupt and Interrupt Handlers</h3><p>An interrupt occurs when a hardware device requires the processor’s attention, such as keyboard input, the Real-Time Clock (RTC), or the Programmable Interrupt Controller (PIC). From the kernel’s perspective, interrupts are <strong>unexpected and unpredictable</strong> since they can occur at any time (and typically unrelated) relative to program execution.</p><p>The OS includes only essential device drivers (see <a href=#supported-devices-and-drivers>Supported Devices and Drivers</a>). The remaining interrupt Request (IRQ) lines are masked and ignored unless explicitly enabled.</p><p>The IRQ lines are managed by <strong>two cascaded Intel 8259 PICs</strong>, following the standard IBM-compatible PC architecture.</p><p>Interrupts are <strong>asynchronous</strong>, meaning they are triggered independently of the program flow. When an interrupt occurs and the processor is notified, the CPU jumps to the appropriate assembly linkage (see <a href=#context-switching-and-assembly-linkages>Context Switching and Assembly Linkages</a>).</p><p>The interrupt assembly linkage <strong>saves the processor state</strong>, then invokes the unified interrupt handler.</p><p>The interrupt handler identifies the source of the interrupt and calls the appropriate device driver, which then performs the necessary processing before execution resumes (see <a href=#supported-devices-and-drivers>Supported Devices and Drivers</a>).</p><h3 id=supported-devices-and-drivers>Supported Devices and Drivers</h3><p>The kernel includes drivers for the <strong>keyboard, Programmable Interval Timer (PIT), Real-Time Clock (RTC), and terminal</strong>.</p><p>The <strong>keyboard, PIT, and RTC drivers</strong> interact with physical devices and include handlers for their respective interrupts (see <a href=#interrupts-and-interrupt-handlers>Interrupts and Interrupt Handlers</a>).</p><ul><li>The <strong>keyboard driver</strong> handles key presses, including uppercase/lowercase typing and combination keys.</li><li>The <strong>PIT and RTC generate periodic interrupts</strong>, each serving different roles in system operation.</li><li>The <strong>PIT driver</strong> is responsible for <strong>process scheduling</strong> and cannot be accessed by user programs (see <a href=#process-switching-and-scheduler>Process Switching and Scheduler</a>).</li><li>The <strong>RTC driver</strong> is <strong>user-accessible</strong> and is <strong>virtualized per process</strong>, meaning each process perceives its own independent RTC instance and frequency.</li></ul><p><em>This design ensures that only the kernel controls the PIT frequency, preventing user programs from tampering with the scheduler.</em></p><p>The <strong>terminal driver</strong> is for <strong>standard I/O operations</strong>, acting as a bridge between user processes, devices, and the kernel.</p><p>The system supports <strong>three virtual terminals</strong> (see <a href=#background-switching-and-multiterminals>Background Switching and Multiterminals</a>). Each terminal maintains a separate <strong>input buffer</strong>, limited to <strong>128 characters</strong>.</p><h3 id=memory-addressing>Memory Addressing</h3><p>The kernel <strong>bypasses segmentation</strong>, similar to most modern operating systems, relying solely on <strong>paging</strong> for memory management.</p><p><strong>Paging</strong> is used exclusively for memory addressing.</p><p>The memory layout is <strong>fixed and predefined</strong> (see <a href=#physical-memory-layout>Physical Memory Layout</a> and <a href=#virtual-memory-layout>Virtual Memory Layout</a>).</p><h3 id=physical-memory-layout>Physical Memory Layout</h3><p>From low to high, the kernel utilizes the following 32MB physical memory:</p><ul><li>4MB space with five 4KB space for the VRAM for the active terminal, 3 terminal backups, and an extra backup space (see <a href=#background-switchingmultiterminals>Multiterminals</a>)</li><li>4MB space for the kernel data (mostly Process Control Blocks (PCBs) and Terminal Info (TI) blocks) and kernel stack (see <a href=#process-controlexecutehalt>Process Control</a> and <a href=#background-switchingmultiterminals>Multiterminals</a>)</li><li>Six 4MB spaces for user applications&rsquo; binary and stack (see <a href=#process-controlexecutehalt>Process Control</a>)</li></ul><h3 id=virtual-memory-layout>Virtual Memory Layout</h3><p>The kernel maps a <strong>4GB virtual address space</strong> for each user program. The memory layout, from low to high, consists of:</p><ul><li><strong>4MB managed by a supervisor Page Table (PT)</strong>, including five <strong>4KB supervisor pages</strong>, mapped to physical memory (see <a href=#physical-memory-layout>Physical Memory Layout</a>).</li><li><strong>4MB supervisor jumbo page for the kernel</strong>, mapped directly to physical memory (see <a href=#physical-memory-layout>Physical Memory Layout</a>).</li><li><strong>4MB user page at virtual address 128MB</strong>, allocated for the <strong>currently running user program</strong> (see <a href=#process-control-execute-and-halt>Process Control</a>).</li><li><strong>4MB managed by a user PT</strong>, including a <strong>4KB vidmap page</strong>, granting user-space access to the video buffer for the active program (see <a href=#system-calls>System Calls</a> and <a href=#background-switching-and-multiterminals>Multiterminals</a>).</li></ul><h3 id=system-calls>System Calls</h3><table><thead><tr><th>System Call</th><th>Description</th></tr></thead><tbody><tr><td><strong>halt</strong></td><td>Terminates the current program (process). For details, see <a href=#process-control-execute-and-halt>Process Control: Execute and Halt</a>.</td></tr><tr><td><strong>execute</strong></td><td>Loads and executes a new program. For details, see <a href=#process-control-execute-and-halt>Process Control: Execute and Halt</a>.</td></tr><tr><td><strong>read</strong></td><td>Reads data from an open file (see <a href=#file-system-abstraction>File System Abstraction</a>).</td></tr><tr><td><strong>write</strong></td><td>Writes data to a file (supported for terminal and RTC devices only).</td></tr><tr><td><strong>open</strong></td><td>Allocates a file descriptor (FD) entry and opens a file.</td></tr><tr><td><strong>close</strong></td><td>Closes an open file descriptor (FD) and releases associated resources.</td></tr><tr><td><strong>getargs</strong></td><td>Retrieves the command-line arguments for the current process, extracted during the <code>execute</code> system call.</td></tr><tr><td><strong>vidmap</strong></td><td>Maps the video memory to a user-accessible virtual address.</td></tr></tbody></table><p>System calls are triggered explicitly by user programs through a <strong>software interrupt</strong> (<code>INT 0x80</code> on x86 systems).</p><p>When a system call is invoked, the processor jumps to the <strong>system call assembly linkage</strong> (see <a href=#context-switching-and-assembly-linkages>Context Switching and Assembly Linkages</a>).</p><p>Arguments for system calls are passed through the <strong>%EAX, %EBX, %ECX, and %EDX registers</strong>.</p><p>The assembly linkage validates the arguments before invoking the corresponding system call handler</p><h3 id=process-controlexecutehalt>Process Control/Execute/Halt</h3><p>The kernel supports up to <strong>six concurrent processes</strong>. In <strong>kernel space</strong>, each process maintains a <strong>kernel stack</strong> and a <strong>Process Control Block (PCB)</strong>.</p><p>In <strong>user space</strong>, each process has its own <strong>dedicated user page</strong> (see <a href=#virtual-memory-layout>Virtual Memory Layout</a>), which contains the <strong>executable binary and a user stack</strong>.</p><p>By maintaining separate <strong>kernel and user stacks</strong>, processes won&rsquo;t overwrite each other’s execution context.</p><p>Each <strong>PCB</strong> tracks:</p><ul><li><strong>Process ID (PID)</strong></li><li><strong>Parent PID</strong></li><li><strong>Terminal ID</strong></li><li><strong>Kernel and user stack pointers</strong></li><li><strong>File descriptors (FDs)</strong></li><li>Other process-specific information</li></ul><h4 id=process-creation-execute-system-call>Process Creation: Execute System Call</h4><p>When <strong>creating a new process</strong> via the <code>execute</code> system call (see <a href=#system-calls>System Calls</a>), the OS follows these steps:</p><ol><li><strong>Sanity checks</strong> – Validates the program binary and extracts arguments.</li><li><strong>Allocate PCB</strong> – Assigns a free PCB slot for the new process.</li><li><strong>Set up user page</strong> – Allocates and maps the new process’s address space.</li><li><strong>Load program binary</strong> – Copies the executable into memory.</li><li><strong>Initialize FDs</strong> – Sets up file descriptors.</li><li><strong>Bookkeeping</strong> – Tracks parent-child process ids to allow process return on exit.</li><li><strong>Context switch setup</strong> – Sets up hardware context with the new <strong>PC</strong> and <strong>user stack</strong>.</li><li><strong>Jump to execution</strong> – Returns to the assembly linkage to perform the context switch (see <a href=#context-switching-and-assembly-linkages>Context Switching and Assembly Linkages</a>).</li></ol><h4 id=process-termination-halt-system-call>Process Termination: Halt System Call</h4><p>When <strong>a process is halted</strong> via the <code>halt</code> system call (see <a href=#system-calls>System Calls</a>), the OS:</p><ol><li><strong>Frees allocated resources</strong> – Releases memory pages, vidmap, and file descriptors.</li><li><strong>Deallocates PCB</strong> – Each process has PCB slots preallocated (based on process ID).</li><li><strong>Restores parent process context</strong> – Retrieves the parent’s execution state.</li><li><strong>Performs context switch back to parent</strong> – Gives control back to the parent process via the assembly linkage.</li></ol><h3 id=process-switchingscheduler>Process Switching/Scheduler</h3><p>The kernel uses a <strong>round-robin scheduler</strong>, triggered by <strong>PIT (Programmable Interval Timer) interrupts</strong> (see <a href=#supported-devices-and-drivers>Supported Devices and Drivers</a>).</p><p>Although the system supports <strong>up to six concurrent processes</strong>, only <strong>three are actively scheduled</strong>, with <strong>one process executing at a time</strong>. The remaining two scheduled processes are <strong>paused until the scheduler reactivates them</strong>.</p><p>The scheduler assigns <strong>one active process per terminal</strong>, continuously cycling through them to enable multitasking. However, since the kernel is designed for a <strong>uniprocessor system</strong>, only <strong>one process is actually running</strong> at any given moment.</p><h4 id=process-switching-mechanism>Process Switching Mechanism</h4><p>When switching between processes, the <strong>kernel saves the current process&rsquo;s hardware context</strong>. This is similar to the <code>halt</code> system call but <strong>preserves all process state and resources</strong>.</p><ol><li><strong>Save current process state</strong> – Registers, stack pointer, and page table mappings are stored.</li><li><strong>Select the next scheduled process</strong> – Based on the round-robin scheme.</li><li><strong>Switch memory context</strong> – Kernel page directory and stack are updated to point to the new process.</li><li><strong>Restore the next process state</strong> – Registers and stack are restored from the saved context.</li><li><strong>Resume execution</strong> – The kernel returns to the system linkage (see <a href=#context-switching-and-assembly-linkages>Context Switching and Assembly Linkages</a>).</li></ol><h3 id=background-switching-and-multiterminals>Background Switching and Multiterminals</h3><p>As mentioned above, the OS supports <strong>up to three active terminals</strong>, each maintaining information about the <strong>currently running process</strong>, <strong>PCB pointer</strong>, and <strong>screen state</strong>. The <strong>scheduler relies on this information</strong> to manage process execution correctly.</p><h4 id=handling-background-process-switching>Handling Background Process Switching</h4><p>When an <strong>active process is switched to the background</strong>, additional operations are required to maintain proper execution and display behavior.</p><p>One key requirement is <strong>VRAM separation</strong> to ensure that processes running do not modify the visible screen output.</p><p>Since a <strong>processes cannot directly print to the display</strong>, the kernel manages <strong>five individual VRAM pages</strong> (see <a href=#physical-memory-layout>Physical Memory Layout</a>). When switching processes, the <strong>kernel remaps the video memory pages</strong> to ensure that respective processes only write to their own VRAM page.</p><h4 id=handling-active-process-switching>Handling Active Process Switching</h4><p>When a <strong>background process is switched to the active one</strong>, the kernel <strong>copies the corresponding VRAM buffer to the display</strong> and <strong>remaps the vidmap</strong> to reflect the new active process.</p><hr><p>I was able to write this Technical Overview thanks to Peizhe&rsquo;s help (<a href=https://os.paizhang.info/>website</a>)</p></div><div class=footer>Powered by <a href=https://gohugo.io/>Hugo</a> with
<a href=https://github.com/mrmierzejewski/hugo-theme-console/>Console Theme</a>.</div></div></body><script type=module>
    import { spawnTeapot } from "teapot";

    
    const container = document.getElementById("teapot-container");
    spawnTeapot(container, {
      containerSize: 50,
      teapotSize: 0.8,
      tessellation: 10,
      baseSpeed: 0.01,
      hoverSpeed: 0.05,
      cameraZ: 3,
    });
  </script></html>